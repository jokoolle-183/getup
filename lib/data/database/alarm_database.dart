import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:equatable/equatable.dart';
import 'package:walk_it_up/constants.dart';
import 'package:walk_it_up/data/database/enum_list_converter.dart';
import 'package:walk_it_up/data/dto/weekdays.dart';

part 'alarm_database.g.dart'; // This will be generated by drift

@DataClassName('RegularAlarm')
class RegularAlarms extends Table with EquatableMixin {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().nullable()();
  TextColumn get audioPath => text()();
  DateTimeColumn get time => dateTime()();
  IntColumn get snoozeDuration => integer().nullable()();
  TextColumn get daysOfWeek =>
      text().map(const EnumListConverter(Weekday.values)).nullable()();
  BoolColumn get isEnabled => boolean().withDefault(const Constant(true))();

  @override
  List<Object?> get props => [
        id,
        name,
        audioPath,
        time,
        snoozeDuration,
        daysOfWeek,
      ];
}

@DataClassName('AlarmSet')
class AlarmSets extends Table with EquatableMixin {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().nullable()();
  TextColumn get audioPath => text()();
  DateTimeColumn get startTime => dateTime()();
  DateTimeColumn get endTime => dateTime()();
  IntColumn get intervalBetweenAlarms => integer()();
  IntColumn get pauseDuration => integer().nullable()();
  TextColumn get daysOfWeek =>
      text().map(const EnumListConverter(Weekday.values)).nullable()();
  BoolColumn get isEnabled => boolean().withDefault(const Constant(true))();

  @override
  List<Object?> get props => [
        id,
        name,
        startTime,
        endTime,
        intervalBetweenAlarms,
        pauseDuration,
        daysOfWeek
      ];
}

@DataClassName('RecurringAlarm')
class RecurringAlarms extends Table with EquatableMixin {
  IntColumn get id => integer().autoIncrement()();
  IntColumn get alarmSetId => integer().references(
        AlarmSets,
        #id,
        onDelete: KeyAction
            .cascade, // If the set is deleted, this will set alarmSetId to null
      )();
  DateTimeColumn get time => dateTime()();
  BoolColumn get isEnabled => boolean().withDefault(const Constant(true))();

  @override
  List<Object?> get props => [
        id,
        alarmSetId,
        time,
        isEnabled,
      ];
}

@DriftDatabase(tables: [RegularAlarms, AlarmSets, RecurringAlarms])
class AlarmDatabase extends _$AlarmDatabase {
  bool isUnderTest = false;

  AlarmDatabase() : super(_openConnection());

  AlarmDatabase.test(QueryExecutor executor) : super(executor) {
    isUnderTest = true;
  }

  static QueryExecutor _openConnection() {
    return driftDatabase(name: ALARM_DATABASE);
  }

  Future<List<RegularAlarm>> get allRegularAlarms =>
      select(regularAlarms).get();

  Future<List<RecurringAlarm>> get allRecurringAlarms =>
      select(recurringAlarms).get();

  Future<List<AlarmSet>> get allAlarmSets => select(alarmSets).get();

  Future<void> saveAlarmSet(
    AlarmSetsCompanion alarmSet,
    List<RecurringAlarmsCompanion> alarmList,
  ) {
    return transaction(() async {
      final id = await into(alarmSets).insert(alarmSet);
      await batch((batch) {
        final alarmsWithParentId = alarmList
            .map((alarm) => alarm.copyWith(alarmSetId: Value(id)))
            .toList();
        batch.insertAll(recurringAlarms, alarmsWithParentId);
      });
    });
  }

  Future<void> updateAlarmSet(
    AlarmSetsCompanion alarmSet,
    List<RecurringAlarmsCompanion> alarmList,
  ) {
    return transaction(() async {
      await update(alarmSets).replace(alarmSet);

      // Update existing alarms under this alarm set
      for (RecurringAlarmsCompanion alarm in alarmList) {
        await (update(recurringAlarms)
              ..where((table) => table.id.equals(alarm.id.value)))
            .write(alarm);
      }
    });
  }

  Future<int> deleteAlarmSet(int id) {
    return (delete(alarmSets)..where((alarmSet) => alarmSet.id.equals(id)))
        .go();
  }

  Future<int> saveAlarm(RegularAlarmsCompanion entry) {
    return into(regularAlarms).insert(entry);
  }

  Future<bool> updateAlarm(RegularAlarmsCompanion entry) {
    return update(regularAlarms).replace(entry);
  }

  Future<int> deleteAlarm(int id) {
    return (delete(regularAlarms)..where((alarm) => alarm.id.equals(id))).go();
  }

  Stream<RegularAlarm> watchAlarmById(int id) {
    return (select(regularAlarms)..where((alarm) => alarm.id.equals(id)))
        .watchSingle();
  }

  Stream<AlarmSet> watchAlarmSetById(int id) {
    return (select(alarmSets)..where((alarmSet) => alarmSet.id.equals(id)))
        .watchSingle();
  }

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration =>
      MigrationStrategy(beforeOpen: (details) async {
        // Prepopulate the db on first creation and in case it's not
        // for testing
        if (details.wasCreated && !isUnderTest) {
          final date = DateTime.now();
          saveAlarm(RegularAlarmsCompanion.insert(
            audioPath: 'assets/perfect_alarm.mp3',
            time: DateTime(date.year, date.month, date.day, 10, 0),
          ));
        }
        // Turned off by default in sqlite 3, needs to be manually activated
        await customStatement('PRAGMA foreign_keys = ON');
      });
}
