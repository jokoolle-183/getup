import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:equatable/equatable.dart';
import 'package:walk_it_up/constants.dart';

part 'alarm_database.g.dart'; // This will be generated by drift

@DataClassName('DbAlarm')
class Alarms extends Table with EquatableMixin {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().nullable()();
  TextColumn get audioPath => text()();
  DateTimeColumn get time => dateTime()();
  IntColumn get snoozeDuration => integer()();
  TextColumn get daysOfWeek => text()();

  @override
  List<Object?> get props => [
        id,
        name,
        audioPath,
        time,
        snoozeDuration,
        daysOfWeek,
      ];
}

@DataClassName('AlarmSet')
class AlarmSets extends Table with EquatableMixin {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text().nullable()();
  DateTimeColumn get startTime => dateTime()();
  DateTimeColumn get endTime => dateTime()();
  IntColumn get intervalBetweenAlarms => integer()();
  IntColumn get pauseDuration => integer().nullable()();
  TextColumn get daysOfWeek => text()();

  @override
  List<Object?> get props => [
        id,
        name,
        startTime,
        endTime,
        intervalBetweenAlarms,
        pauseDuration,
        daysOfWeek
      ];
}

class AlarmSetAlarms extends Table {
  IntColumn get alarmSetId => integer().references(
        AlarmSets,
        #id,
        onDelete: KeyAction.cascade,
      )();
  IntColumn get alarmId => integer().references(
        Alarms,
        #id,
        onDelete: KeyAction.cascade,
      )();

  @override
  Set<Column> get primaryKey => {alarmSetId, alarmId};
}

@DriftDatabase(tables: [Alarms, AlarmSets, AlarmSetAlarms])
class AlarmDatabase extends _$AlarmDatabase {
  AlarmDatabase() : super(_openConnection());
  AlarmDatabase.test(QueryExecutor executor) : super(executor);

  static QueryExecutor _openConnection() {
    // `driftDatabase` from `package:drift_flutter` stores the database in
    // `getApplicationDocumentsDirectory()`.
    return driftDatabase(name: ALARM_DATABASE);
  }

  Future<List<DbAlarm>> get allAlarms => select(alarms).get();

  Future<List<AlarmSet>> get allAlarmSets => select(alarmSets).get();

  Future<List<AlarmSetAlarm>> get allAlarmSetAlarms =>
      select(alarmSetAlarms).get();

  Future<void> saveAlarmSet(
    AlarmSetsCompanion alarmSet,
    List<AlarmsCompanion> alarms,
  ) {
    return transaction(() async {
      await saveMultipleAlarms(alarms);
      await into(alarmSets).insert(alarmSet);
      await batch((batch) {
        batch.insertAll(alarmSetAlarms, [
          ...alarms.map((alarm) {
            return AlarmSetAlarmsCompanion.insert(
              alarmSetId: alarmSet.id.value,
              alarmId: alarm.id.value,
            );
          })
        ]);
      });
    });
  }

  Future<int> saveAlarm(AlarmsCompanion entry) {
    return into(alarms).insert(entry);
  }

  Future<void> saveMultipleAlarms(List<AlarmsCompanion> entries) async {
    await batch((batch) {
      batch.insertAll(alarms, entries);
    });
  }

  Stream<DbAlarm> watchAlarmById(int id) {
    return (select(alarms)..where((alarm) => alarm.id.equals(id)))
        .watchSingle();
  }

  Stream<AlarmSet> watchAlarmSetById(int id) {
    return (select(alarmSets)..where((alarmSet) => alarmSet.id.equals(id)))
        .watchSingle();
  }

  Stream<AlarmSetAlarm> watchWithId(int id) {
    return (select(alarmSetAlarms)
          ..where((alarmSetAlarms) => alarmSetAlarms.alarmSetId.equals(id)))
        .watchSingle();
  }

  @override
  int get schemaVersion => 2;
}
